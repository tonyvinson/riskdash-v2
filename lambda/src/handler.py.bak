import json
import boto3
import uuid
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Any, Optional
import os
import logging
from boto3.dynamodb.conditions import Key, Attr
from decimal import Decimal

# Setup logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Environment variables
TENANTS_TABLE = os.environ.get('TENANTS_TABLE', 'ksi-mvp-tenants-dev')
EXECUTIONS_TABLE = os.environ.get('EXECUTIONS_TABLE', 'ksi-mvp-executions-dev')
VALIDATION_RULES_TABLE = os.environ.get('VALIDATION_RULES_TABLE', 'ksi-mvp-validation-rules-dev')
TENANT_OVERRIDES_TABLE = os.environ.get('TENANT_OVERRIDES_TABLE', 'ksi-mvp-tenant-rule-overrides-dev')

dynamodb = boto3.resource('dynamodb')

def clean_dynamodb_item(item):
    """Convert DynamoDB item to JSON serializable format"""
    if isinstance(item, list):
        return [clean_dynamodb_item(i) for i in item]
    elif isinstance(item, dict):
        return {k: clean_dynamodb_item(v) for k, v in item.items()}
    elif isinstance(item, Decimal):
        return int(item) if item % 1 == 0 else float(item)
    return item

def cors_response(status_code: int, body: dict):
    """Return CORS-enabled response"""
    return {
        'statusCode': status_code,
        'headers': {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
            'Content-Type': 'application/json'
        },
        'body': json.dumps(clean_dynamodb_item(body), default=str)
    }

def lambda_handler(event, context):
    """Main Lambda handler - supports individual tenant EventBridge scheduling"""
    
    logger.info(f"Received event: {json.dumps(event)}")
    
    # üïê Handle EventBridge scheduled events (individual tenant)
    if event.get('source') == 'eventbridge-scheduler':
        logger.info("üïê Processing scheduled EventBridge validation for individual tenant")
        return handle_individual_tenant_scheduled_event(event, context)
    
    # üïê Handle direct EventBridge rules
    if event.get('source') == 'aws.events':
        logger.info("üïê Processing AWS EventBridge rule for individual tenant")
        return handle_individual_tenant_scheduled_event(event, context)
    
    # Handle CORS preflight requests
    if event.get('httpMethod') == 'OPTIONS':
        return {
            'statusCode': 200,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
                'Access-Control-Max-Age': '86400'
            },
            'body': json.dumps({'message': 'CORS preflight successful'})
        }
    
    # Handle API Gateway requests (existing functionality)
    if 'httpMethod' in event:
        return handle_api_gateway_request(event, context)
    
    # Unknown event type
    logger.warning("Unknown event type received")
    return {'statusCode': 400, 'body': json.dumps({'error': 'Unknown event type'})}

def handle_individual_tenant_scheduled_event(event, context):
    """üïê Handle scheduled validation for individual tenant (no ALL_TENANTS)"""
    try:
        # Extract tenant info directly from EventBridge event
        tenant_id = event.get('tenant_id')
        tenant_name = event.get('tenant_name', 'Unknown Tenant')
        trigger_source = event.get('trigger_source', 'scheduled_daily_individual')
        offset_minutes = event.get('offset_minutes', 0)
        
        logger.info(f"üïê Starting scheduled validation for individual tenant: {tenant_id} ({tenant_name})")
        logger.info(f"üïê Trigger source: {trigger_source}, Offset: {offset_minutes} minutes")
        
        if not tenant_id:
            raise ValueError("tenant_id is required for individual tenant scheduling")
        
        # Prepare validation request for this specific tenant
        validation_request = {
            'tenant_id': tenant_id,
            'trigger_source': trigger_source,
            'validate_all': event.get('validate_all', True),
            'scheduled_run': True,
            'ksi_categories': event.get('ksi_categories', []),  # For weekly runs
            'schedule_frequency': event.get('schedule_frequency', 'daily')
        }
        
        logger.info(f"üïê Validation request: {validation_request}")
        
        # Execute validation using existing trigger_ksi_validation function
        result = trigger_ksi_validation(validation_request)
        result_data = json.loads(result['body'])
        
        if result['statusCode'] == 200:
            logger.info(f"‚úÖ Scheduled validation completed successfully for {tenant_id}")
            logger.info(f"üìä Results: {result_data.get('ksis_validated', 0)} KSIs validated")
            
            # Return success response for EventBridge
            return {
                'statusCode': 200,
                'body': json.dumps({
                    'status': 'success',
                    'tenant_id': tenant_id,
                    'tenant_name': tenant_name,
                    'trigger_source': trigger_source,
                    'ksis_validated': result_data.get('ksis_validated', 0),
                    'execution_id': result_data.get('execution_id'),
                    'timestamp': datetime.now(timezone.utc).isoformat(),
                    'message': f'Scheduled validation completed for {tenant_name}'
                })
            }
        else:
            logger.error(f"‚ùå Scheduled validation failed for {tenant_id}: {result_data.get('error')}")
            raise Exception(f"Validation failed: {result_data.get('error')}")
            
    except Exception as e:
        logger.error(f"‚ùå Error in scheduled validation: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({
                'status': 'error',
                'tenant_id': event.get('tenant_id', 'unknown'),
                'error': str(e),
                'timestamp': datetime.now(timezone.utc).isoformat()
            })
        }

def handle_api_gateway_request(event, context):
    """Handle API Gateway requests (existing functionality)"""
    path = event.get('path', '')
    method = event.get('httpMethod', '')
    
    logger.info(f"Processing API request: {method} {path}")
    
    try:
        # Health check
        if path == '/api/health':
            return cors_response(200, {
                'status': 'healthy', 
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'version': '2.0',
                'features': ['api_gateway', 'individual_tenant_scheduling', 'ksi_validation']
            })
        
        # KSI validation routes
        elif path.startswith('/api/ksi/'):
            return handle_ksi_validation_routes(event, context)
        
        # Admin routes
        elif path.startswith('/api/admin/'):
            return handle_admin_routes(event, context)
        
        # Tenant routes  
        elif path.startswith('/api/tenant/'):
            return handle_tenant_routes(event, context)
        
        else:
            return cors_response(404, {'error': f'Route not found: {path}'})
            
    except Exception as e:
        logger.error(f"Error processing API request: {str(e)}")
        return cors_response(500, {'error': str(e)})

def handle_admin_routes(event, context):
    """Handle admin API requests with all missing endpoints"""
    path = event.get('path', '')
    method = event.get('httpMethod', '')
    
    logger.info(f"Admin route: {method} {path}")
    
    # KSI Defaults endpoint
    if path == '/api/admin/ksi-defaults':
        if method == 'GET':
            return get_ksi_defaults()
    
    # Tenants management
    elif path == '/api/admin/tenants':
        if method == 'GET':
            return get_all_tenants()
        elif method == 'POST':
            return create_tenant(json.loads(event['body']))
    
    # System status
    elif path == '/api/admin/system/status':
        if method == 'GET':
            return get_system_status()
    
    return cors_response(404, {'error': f'Admin route not found: {path}'})

def get_ksi_defaults():
    """Get all available KSI definitions"""
    try:
        rules_table = dynamodb.Table(VALIDATION_RULES_TABLE)
        response = rules_table.scan()
        
        available_ksis = []
        for item in response.get('Items', []):
            # Determine automation type
            validation_steps = item.get('validation_steps', [])
            automation_type = item.get('automation_type', 'manual')
            
            if validation_steps and not automation_type:
                has_cli = any('service' in step and 'action' in step for step in validation_steps)
                automation_type = 'fully_automated' if has_cli else 'manual'
            
            ksi_info = {
                'ksi_id': item.get('ksi_id') or item.get('rule_id'),
                'title': item.get('title', 'Unknown KSI'),
                'category': item.get('category', 'Unknown'),
                'automation_type': automation_type,
                'validation_steps': len(validation_steps),
                'description': item.get('description', ''),
                'compliance_framework': item.get('compliance_framework', 'FedRAMP-20x')
            }
            available_ksis.append(ksi_info)
        
        available_ksis.sort(key=lambda x: x['ksi_id'])
        
        return cors_response(200, {
            'available_ksis': available_ksis,
            'total_count': len(available_ksis),
            'automation_summary': {
                'fully_automated': len([k for k in available_ksis if k['automation_type'] == 'fully_automated']),
                'partially_automated': len([k for k in available_ksis if k['automation_type'] == 'partially_automated']),
                'manual': len([k for k in available_ksis if k['automation_type'] == 'manual'])
            }
        })
        
    except Exception as e:
        logger.error(f"Error getting KSI defaults: {str(e)}")
        return cors_response(500, {'error': str(e)})

def get_all_tenants():
    """Get all tenants"""
    try:
        tenants_table = dynamodb.Table(TENANTS_TABLE)
        response = tenants_table.scan()
        
        tenants = []
        for item in response.get('Items', []):
            tenant_info = {
                'tenant_id': item.get('tenant_id'),
                'tenant_name': item.get('tenant_name'),
                'status': item.get('status', 'active'),
                'created_date': item.get('created_date')
            }
            tenants.append(tenant_info)
        
        return cors_response(200, {'tenants': tenants})
        
    except Exception as e:
        logger.error(f"Error getting tenants: {str(e)}")
        return cors_response(500, {'error': str(e)})

def create_tenant(tenant_data):
    """Create a new tenant"""
    try:
        tenant_id = f"tenant-{uuid.uuid4().hex[:8]}"
        
        tenant_record = {
            'tenant_id': tenant_id,
            'tenant_name': tenant_data.get('tenant_name', 'New Tenant'),
            'status': 'active',
            'created_date': datetime.now(timezone.utc).isoformat()
        }
        
        tenants_table = dynamodb.Table(TENANTS_TABLE)
        tenants_table.put_item(Item=tenant_record)
        
        return cors_response(201, {
            'message': 'Tenant created successfully',
            'tenant_id': tenant_id
        })
        
    except Exception as e:
        logger.error(f"Error creating tenant: {str(e)}")
        return cors_response(500, {'error': str(e)})

def get_system_status():
    """Get system status"""
    try:
        return cors_response(200, {
            'status': 'healthy',
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'version': '2.0',
            'scheduling': 'individual_tenant'
        })
    except Exception as e:
        return cors_response(500, {'error': str(e)})

# KSI Validation Routes
def handle_ksi_validation_routes(event, context):
    """Handle KSI validation execution routes"""
    path = event.get('path', '')
    method = event.get('httpMethod', '')
    
    if path == '/api/ksi/validate':
        if method == 'POST':
            return trigger_ksi_validation(json.loads(event['body']))
    
    elif path.startswith('/api/ksi/results'):
        if method == 'GET':
            query_params = event.get('queryStringParameters') or {}
            tenant_id = query_params.get('tenant_id')
            return get_validation_results(tenant_id)
    
    elif path.startswith('/api/ksi/executions'):
        if method == 'GET':
            query_params = event.get('queryStringParameters') or {}
            tenant_id = query_params.get('tenant_id')
            return get_execution_history(tenant_id)
    
    return cors_response(404, {'error': 'KSI validation route not found'})

def trigger_ksi_validation(validation_request):
    """Execute KSI validation for a single tenant"""
    logger.info(f"Triggering KSI validation: {validation_request}")
    
    try:
        tenant_id = validation_request.get('tenant_id')
        trigger_source = validation_request.get('trigger_source', 'frontend')
        ksi_filter = validation_request.get('ksi_filter', [])
        validate_all = validation_request.get('validate_all', False)
        ksi_categories = validation_request.get('ksi_categories', [])
        
        if not tenant_id:
            return cors_response(400, {'error': 'tenant_id is required'})
        
        execution_id = f"exec-{int(datetime.now(timezone.utc).timestamp())}-{uuid.uuid4().hex[:8]}"
        logger.info(f"Starting validation execution: {execution_id} for tenant: {tenant_id}")
        
        # Get KSI validation rules from database
        rules_table = dynamodb.Table(VALIDATION_RULES_TABLE)
        response = rules_table.scan()
        available_ksis = response.get('Items', [])
        
        logger.info(f"Found {len(available_ksis)} KSI rules in database")
        
        # Filter KSIs if specified
        if ksi_filter and not validate_all:
            available_ksis = [ksi for ksi in available_ksis if ksi.get('ksi_id') in ksi_filter or ksi.get('rule_id') in ksi_filter]
            logger.info(f"Filtered to {len(available_ksis)} KSIs by ID: {ksi_filter}")
        
        # Filter by categories for weekly runs
        if ksi_categories:
            available_ksis = [ksi for ksi in available_ksis if ksi.get('category') in ksi_categories]
            logger.info(f"Filtered to {len(available_ksis)} KSIs by categories: {ksi_categories}")
        
        if not available_ksis:
            return cors_response(400, {'error': 'No KSI rules found to validate'})
        
        # Create execution summary record
        executions_table = dynamodb.Table(EXECUTIONS_TABLE)
        execution_record = {
            'execution_id': execution_id,
            'tenant_id': tenant_id,
            'trigger_source': trigger_source,
            'status': 'completed',
            'ksis_validated': len(available_ksis),
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'record_type': 'execution_summary'
        }
        executions_table.put_item(Item=execution_record)
        logger.info(f"Created execution summary record")
        
        # Execute validation for each KSI and store results
        validation_results = []
        for ksi_rule in available_ksis:
            ksi_id = ksi_rule.get('ksi_id') or ksi_rule.get('rule_id')
            
            # For MVP, simulate validation with mix of pass/fail
            # In production, this would execute real AWS CLI commands
            import random
            assertion = random.choice([True, True, True, False])  # 75% pass rate
            
            result = {
                'ksi_id': ksi_id,
                'execution_id': execution_id,
                'tenant_id': tenant_id,
                'assertion': assertion,
                'assertion_reason': f"‚úÖ {ksi_rule.get('title', ksi_id)} validation passed" if assertion else f"‚ùå {ksi_rule.get('title', ksi_id)} validation failed",
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'commands_executed': len(ksi_rule.get('validation_steps', [])),
                'successful_commands': len(ksi_rule.get('validation_steps', [])) if assertion else 0,
                'failed_commands': 0 if assertion else len(ksi_rule.get('validation_steps', [])),
                'category': ksi_rule.get('category', 'Unknown'),
                'record_type': 'result'
            }
            
            # Store result in DynamoDB
            executions_table.put_item(Item=result)
            validation_results.append(result)
            
            logger.info(f"Stored validation result for {ksi_id}: {'PASS' if assertion else 'FAIL'}")
        
        logger.info(f"Completed validation execution {execution_id} with {len(validation_results)} results")
        
        return cors_response(200, {
            'status': 'success',
            'execution_id': execution_id,
            'tenant_id': tenant_id,
            'ksis_validated': len(validation_results),
            'validation_results': validation_results,
            'message': f'Validation completed successfully for {len(validation_results)} KSIs'
        })
        
    except Exception as e:
        logger.error(f"Error in KSI validation: {str(e)}")
        return cors_response(500, {'error': f'Validation failed: {str(e)}'})

def get_validation_results(tenant_id):
    """Get validation results for tenant"""
    try:
        executions_table = dynamodb.Table(EXECUTIONS_TABLE)
        
        if tenant_id:
            response = executions_table.scan(
                FilterExpression=Attr('tenant_id').eq(tenant_id) & Attr('record_type').eq('result')
            )
        else:
            response = executions_table.scan(
                FilterExpression=Attr('record_type').eq('result')
            )
        
        results = response.get('Items', [])
        results.sort(key=lambda x: x.get('timestamp', ''), reverse=True)
        
        return cors_response(200, {'results': results})
        
    except Exception as e:
        logger.error(f"Error getting validation results: {str(e)}")
        return cors_response(500, {'error': str(e)})

def get_execution_history(tenant_id):
    """Get execution history"""
    try:
        executions_table = dynamodb.Table(EXECUTIONS_TABLE)
        
        if tenant_id:
            response = executions_table.scan(
                FilterExpression=Attr('tenant_id').eq(tenant_id)
            )
        else:
            response = executions_table.scan()
        
        executions = []
        for item in response.get('Items', []):
            if not item.get('record_type') or item.get('record_type') == 'execution_summary':
                executions.append({
                    'execution_id': item.get('execution_id'),
                    'tenant_id': item.get('tenant_id'),
                    'timestamp': item.get('timestamp'),
                    'ksis_validated': item.get('ksis_validated', 0),
                    'status': item.get('status', 'completed')
                })
        
        executions.sort(key=lambda x: x.get('timestamp', ''), reverse=True)
        
        return cors_response(200, {'executions': executions[:10]})
        
    except Exception as e:
        logger.error(f"Error getting execution history: {str(e)}")
        return cors_response(500, {'error': str(e)})

def handle_tenant_routes(event, context):
    """Handle tenant routes"""
    return cors_response(200, {'message': 'Tenant routes working'})
